给你一些用户日志，其中每条日志包括时间戳和具体的日志内容。请你针对指定范围内的每条日志，分别生成其与先前日志的关联列表。具体来说，假设当前日志对应的事件为<事件B>，先前的某个日志对应于<事件A>，考虑两种关联类型：
1. "caused_by": <事件A>是<事件B>的直接原因。若<事件A>没有出现，则<事件B>不会出现。
2. "follows": <事件B>与<事件A>属于相同的主题，且在时序上具有顺承关系，即<事件B>在时间上接续<事件A>。但<事件B>的发生并不完全依赖于<事件A>。

# 日志
"""
<logs>
"""

# 具体要求及输出模板
## 具体要求
对于输入中（<logs_id_span>）范围内的每条日志，你需要分别考虑其与先前日志的两种关联，并分别列举出"caused_by"和"follows"两种类型下的先前日志id。
注意：
1. 你需要依次遍历指定范围内的各条日志并生成输出结果。对于某条日志，其输出的关联日志必须早于其出现（关联日志可以包括指定范围之前的日志）。
2. 仅考虑较为明显的直接关联即可，无需考虑间接关联。如"log_0"导致了"log_2"，而"log_2"又导致了"log_4"，此时可不考虑"log_0"导致了"log_4"的关联关系。
3. 需要按照"caused_by", "follows"的顺序依次考虑两种关联关系。如果某两个日志已经被认为存在"caused_by"的关联，就不要再考虑它们之间的"follows"关联。仅当两个日志之间不存在"caused_by关联时，才考虑两者之间是否存在"follows"关联。
4. 仿造下面的输出示例，以json格式输出。除要求的json格式输出外，不要输出任何其它内容，也不需要在json中添加注释进行额外说明。

## 输出模板
"""
{
    "<start_log_id>": { // 当前日志
        "caused_by": [...], // 对应关联类型下的先前日志id，若无关联日志则列表为空
        "follows": [...]
    },
    ... // 需要遍历指定日志范围（<logs_id_span>）中的所有日志项
}
"""

现在，请你按照上面的要求和格式，给出各条日志对应的关联日志列表。